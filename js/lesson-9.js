// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

// I. ПРОТОТИП ОБЪЕКТА

// https://youtu.be/-WXnsjoPCmg

// Прототип - это объект, который содержит нужную для другого объекта информацию
// Где-то отдельно в памяти лежат коллекции методов для отдельных сущностей
// Каждая сущность получает ссылку на коллекцию и использует методы, которые в ней сохраняются

// Статический метод create() на конструкторе Object

// Используется, чтобы сделать один объект прототипом другого
// ОН берет пустой объект и записывает в его свойство __proto__ ссылку на другой объект (прототип)

const objA = { x: 1, y: 2 };

const objB = Object.create(objA);
// Делает objA прототипом objB

// Изменять прототип готового объекта можно, но "это очень нехорошо и не надо этого делать".
// Поэтому сначала создаем пустой объект, с помощью Object.create() указываем его прототип,
// а уже потом добавляем в него нужные свойства

objB.z = 3;

console.log(objB);
// z: 3
// __proto__: Object;

// Свойство __proto__ есть абсолютно у всех объектов (массивов, функций, объектов)
// Оно хранит в себе ссылку на прототип
// В Спецификации это свойство обозначается как [[Prorotype]]
// В браузере - __proto__

// Цепочка прототипов

/*

    B                    A                    Object.prototype    
    { }          -->     { }          -->     { }                 -->    null
    __proto__            __proto__            __proto__

*/

// Правило поиска свойства в цепочке прототипов

console.log(objB.x); // 1
console.log(objB.y); // 2
console.log(objB.z); // 3

// Когда интерпретатор встречает обращение к свойству объекта, сначала он ищет в самом объекте.
// Если не находит, смотрит в свойство __proto__.
// Если там лежит ссылка на другой объект, заходит в этот объект и ищет в нем.
// Поиск идет до первого совпадения.
// Если искомого свойства нет, вернется undefined

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

// II. Основы ООП: КЛАСС, ОБЪЕКТ, ИНТЕРФЕЙС

// https://youtu.be/-WXnsjoPCmg?t=987

// Объектно-ориентированое программирование (ООП) - это old-school о том, как писать код
// Сейчас используется процедурное программирование (ПП)

// Класс - это схема, по которой создаются объекты (экземпляры)
// Он включает набор свойств, имена которых у каждого объекта будут одинаковыми, значения - разными

// Объект (экземпляр) - это отдельный представитель класса
// Имеет интерфейс - свойства и методы для работы с ними

// Интерфейс - это набор доступниых свойств и методов экземпляра

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

// III. ФУНКЦИИ-КОНСТРУКТОРЫ (ФК)

// https://youtu.be/-WXnsjoPCmg?t=1373

// ФК - это самая обычная функция, которая вызывается специальным образом
// Чтобы отличить ФК от обычной функции, ее название пишут с большой буквы
// Названия таких функций - существительные, а не глаголы
// Результат вызова - объект

const Manager = function (name, sales) {
  this.name = name;
  this.sales = sales;
};

const mango = new Manager('Mango', 10);
console.log(mango); // Manager {name: "Mango", sales: 10}

const poly = new Manager('Poly', 15);
console.log(poly); // Manager {name: "Poly", sales: 15}

//    Механизм:
// 1. Оператор new создает новый пустой объект
// 2. ФК вызывается в контексте этого объекта
// 3. Ключевое слово this внутри тела этой функции получает ссылку на этот объект
// 4. После того как ФК закончила свое выполнение, на место ее вызова оператор new возвращает новосозданный объект

// ФК - это класс (схема, по которой создаются объекты)
// Все объекты имеют одинаковый набор свойств, значения которых - разные

// ФК позволяет динамически создавать объекты с одинковымы именами свойств, но разными их значениями

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

// IV. СВОЙСТВО Function.prototype

// https://youtu.be/-WXnsjoPCmg?t=1871

// У каждой функции есть свойство prototype (не важно, это ФК или нет)
// По умолчанию это объект
// Изначально у него есть свойство constructor, в котором лежит ссылка на саму функцию

// В свойстве prototype лежит ссылка на независымый объект (библиотеку методов для работы со свойствами экземпляров,
// которые будут созданы с помощью ФК)

// При вызове ФК с помощью оператора new среди прочего в свойство __proto__ созданного объекта записывается ссылка на
// свойство prototype ФК

Manager.prototype.sell = function () {
  this.sales += 1;
};

mango.sell();
console.log(mango); // Manager {name: "Mango", sales: 11}

Manager.prototype.changeName = function (name) {
  this.name = name;
};

poly.changeName('Pollly');
console.log(poly); // Manager {name: "Pollly", sales: 15}

// Итоги:

// https://youtu.be/-WXnsjoPCmg?t=2225

// https://youtu.be/-WXnsjoPCmg?t=2482

console.log(poly.__proto__ === Manager.prototype); // true

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
